// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UsbProConfigMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "UsbProConfigMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ola {
namespace plugin {
namespace usbpro {

namespace {

const ::google::protobuf::Descriptor* ParameterReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ParameterReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* ParameterRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ParameterRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerialNumberReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerialNumberReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortAssignmentReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortAssignmentReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Request_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Reply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Reply_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Reply_ReplyType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_UsbProConfigMessages_2eproto() {
  protobuf_AddDesc_UsbProConfigMessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "UsbProConfigMessages.proto");
  GOOGLE_CHECK(file != NULL);
  ParameterReply_descriptor_ = file->message_type(0);
  static const int ParameterReply_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, firmware_high_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, firmware_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, break_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, mab_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, rate_),
  };
  ParameterReply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ParameterReply_descriptor_,
      ParameterReply::default_instance_,
      ParameterReply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterReply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ParameterReply));
  ParameterRequest_descriptor_ = file->message_type(1);
  static const int ParameterRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterRequest, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterRequest, break_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterRequest, mab_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterRequest, rate_),
  };
  ParameterRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ParameterRequest_descriptor_,
      ParameterRequest::default_instance_,
      ParameterRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParameterRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ParameterRequest));
  SerialNumberReply_descriptor_ = file->message_type(2);
  static const int SerialNumberReply_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialNumberReply, serial_),
  };
  SerialNumberReply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerialNumberReply_descriptor_,
      SerialNumberReply::default_instance_,
      SerialNumberReply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialNumberReply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerialNumberReply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerialNumberReply));
  PortAssignmentReply_descriptor_ = file->message_type(3);
  static const int PortAssignmentReply_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortAssignmentReply, port_assignment1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortAssignmentReply, port_assignment2_),
  };
  PortAssignmentReply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortAssignmentReply_descriptor_,
      PortAssignmentReply::default_instance_,
      PortAssignmentReply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortAssignmentReply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortAssignmentReply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortAssignmentReply));
  Request_descriptor_ = file->message_type(4);
  static const int Request_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, parameters_),
  };
  Request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Request_descriptor_,
      Request::default_instance_,
      Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Request));
  Request_RequestType_descriptor_ = Request_descriptor_->enum_type(0);
  Reply_descriptor_ = file->message_type(5);
  static const int Reply_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, parameters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, port_assignment_),
  };
  Reply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Reply_descriptor_,
      Reply::default_instance_,
      Reply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Reply));
  Reply_ReplyType_descriptor_ = Reply_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_UsbProConfigMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ParameterReply_descriptor_, &ParameterReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ParameterRequest_descriptor_, &ParameterRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerialNumberReply_descriptor_, &SerialNumberReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortAssignmentReply_descriptor_, &PortAssignmentReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Request_descriptor_, &Request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Reply_descriptor_, &Reply::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_UsbProConfigMessages_2eproto() {
  delete ParameterReply::default_instance_;
  delete ParameterReply_reflection_;
  delete ParameterRequest::default_instance_;
  delete ParameterRequest_reflection_;
  delete SerialNumberReply::default_instance_;
  delete SerialNumberReply_reflection_;
  delete PortAssignmentReply::default_instance_;
  delete PortAssignmentReply_reflection_;
  delete Request::default_instance_;
  delete Request_reflection_;
  delete Reply::default_instance_;
  delete Reply_reflection_;
}

void protobuf_AddDesc_UsbProConfigMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\032UsbProConfigMessages.proto\022\021ola.plugin"
    ".usbpro\"m\n\016ParameterReply\022\025\n\rfirmware_hi"
    "gh\030\001 \002(\r\022\020\n\010firmware\030\002 \002(\r\022\022\n\nbreak_time"
    "\030\003 \002(\r\022\020\n\010mab_time\030\004 \002(\r\022\014\n\004rate\030\005 \002(\r\"W"
    "\n\020ParameterRequest\022\017\n\007port_id\030\004 \002(\r\022\022\n\nb"
    "reak_time\030\001 \001(\r\022\020\n\010mab_time\030\002 \001(\r\022\014\n\004rat"
    "e\030\003 \001(\r\"#\n\021SerialNumberReply\022\016\n\006serial\030\001"
    " \002(\t\"I\n\023PortAssignmentReply\022\030\n\020port_assi"
    "gnment1\030\001 \002(\r\022\030\n\020port_assignment2\030\002 \002(\r\""
    "\344\001\n\007Request\0224\n\004type\030\001 \002(\0162&.ola.plugin.u"
    "sbpro.Request.RequestType\0227\n\nparameters\030"
    "\002 \001(\0132#.ola.plugin.usbpro.ParameterReque"
    "st\"j\n\013RequestType\022\034\n\030USBPRO_PARAMETER_RE"
    "QUEST\020\001\022\031\n\025USBPRO_SERIAL_REQUEST\020\002\022\"\n\036US"
    "BPRO_PORT_ASSIGNMENT_REQUEST\020\003\"\322\002\n\005Reply"
    "\0220\n\004type\030\001 \002(\0162\".ola.plugin.usbpro.Reply"
    ".ReplyType\0225\n\nparameters\030\002 \001(\0132!.ola.plu"
    "gin.usbpro.ParameterReply\022;\n\rserial_numb"
    "er\030\003 \001(\0132$.ola.plugin.usbpro.SerialNumbe"
    "rReply\022\?\n\017port_assignment\030\004 \001(\0132&.ola.pl"
    "ugin.usbpro.PortAssignmentReply\"b\n\tReply"
    "Type\022\032\n\026USBPRO_PARAMETER_REPLY\020\001\022\027\n\023USBP"
    "RO_SERIAL_REPLY\020\002\022 \n\034USBPRO_PORT_ASSIGNM"
    "ENT_REPLY\020\003", 931);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "UsbProConfigMessages.proto", &protobuf_RegisterTypes);
  ParameterReply::default_instance_ = new ParameterReply();
  ParameterRequest::default_instance_ = new ParameterRequest();
  SerialNumberReply::default_instance_ = new SerialNumberReply();
  PortAssignmentReply::default_instance_ = new PortAssignmentReply();
  Request::default_instance_ = new Request();
  Reply::default_instance_ = new Reply();
  ParameterReply::default_instance_->InitAsDefaultInstance();
  ParameterRequest::default_instance_->InitAsDefaultInstance();
  SerialNumberReply::default_instance_->InitAsDefaultInstance();
  PortAssignmentReply::default_instance_->InitAsDefaultInstance();
  Request::default_instance_->InitAsDefaultInstance();
  Reply::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_UsbProConfigMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_UsbProConfigMessages_2eproto {
  StaticDescriptorInitializer_UsbProConfigMessages_2eproto() {
    protobuf_AddDesc_UsbProConfigMessages_2eproto();
  }
} static_descriptor_initializer_UsbProConfigMessages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int ParameterReply::kFirmwareHighFieldNumber;
const int ParameterReply::kFirmwareFieldNumber;
const int ParameterReply::kBreakTimeFieldNumber;
const int ParameterReply::kMabTimeFieldNumber;
const int ParameterReply::kRateFieldNumber;
#endif  // !_MSC_VER

ParameterReply::ParameterReply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.usbpro.ParameterReply)
}

void ParameterReply::InitAsDefaultInstance() {
}

ParameterReply::ParameterReply(const ParameterReply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.ParameterReply)
}

void ParameterReply::SharedCtor() {
  _cached_size_ = 0;
  firmware_high_ = 0u;
  firmware_ = 0u;
  break_time_ = 0u;
  mab_time_ = 0u;
  rate_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParameterReply::~ParameterReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.ParameterReply)
  SharedDtor();
}

void ParameterReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ParameterReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParameterReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParameterReply_descriptor_;
}

const ParameterReply& ParameterReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_UsbProConfigMessages_2eproto();
  return *default_instance_;
}

ParameterReply* ParameterReply::default_instance_ = NULL;

ParameterReply* ParameterReply::New() const {
  return new ParameterReply;
}

void ParameterReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ParameterReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(firmware_high_, rate_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ParameterReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.usbpro.ParameterReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 firmware_high = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &firmware_high_)));
          set_has_firmware_high();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_firmware;
        break;
      }

      // required uint32 firmware = 2;
      case 2: {
        if (tag == 16) {
         parse_firmware:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &firmware_)));
          set_has_firmware();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_break_time;
        break;
      }

      // required uint32 break_time = 3;
      case 3: {
        if (tag == 24) {
         parse_break_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &break_time_)));
          set_has_break_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_mab_time;
        break;
      }

      // required uint32 mab_time = 4;
      case 4: {
        if (tag == 32) {
         parse_mab_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mab_time_)));
          set_has_mab_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_rate;
        break;
      }

      // required uint32 rate = 5;
      case 5: {
        if (tag == 40) {
         parse_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rate_)));
          set_has_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.usbpro.ParameterReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.usbpro.ParameterReply)
  return false;
#undef DO_
}

void ParameterReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.usbpro.ParameterReply)
  // required uint32 firmware_high = 1;
  if (has_firmware_high()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->firmware_high(), output);
  }

  // required uint32 firmware = 2;
  if (has_firmware()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->firmware(), output);
  }

  // required uint32 break_time = 3;
  if (has_break_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->break_time(), output);
  }

  // required uint32 mab_time = 4;
  if (has_mab_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->mab_time(), output);
  }

  // required uint32 rate = 5;
  if (has_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->rate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.usbpro.ParameterReply)
}

::google::protobuf::uint8* ParameterReply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.ParameterReply)
  // required uint32 firmware_high = 1;
  if (has_firmware_high()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->firmware_high(), target);
  }

  // required uint32 firmware = 2;
  if (has_firmware()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->firmware(), target);
  }

  // required uint32 break_time = 3;
  if (has_break_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->break_time(), target);
  }

  // required uint32 mab_time = 4;
  if (has_mab_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->mab_time(), target);
  }

  // required uint32 rate = 5;
  if (has_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->rate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.ParameterReply)
  return target;
}

int ParameterReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 firmware_high = 1;
    if (has_firmware_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->firmware_high());
    }

    // required uint32 firmware = 2;
    if (has_firmware()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->firmware());
    }

    // required uint32 break_time = 3;
    if (has_break_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->break_time());
    }

    // required uint32 mab_time = 4;
    if (has_mab_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mab_time());
    }

    // required uint32 rate = 5;
    if (has_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParameterReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ParameterReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ParameterReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ParameterReply::MergeFrom(const ParameterReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_firmware_high()) {
      set_firmware_high(from.firmware_high());
    }
    if (from.has_firmware()) {
      set_firmware(from.firmware());
    }
    if (from.has_break_time()) {
      set_break_time(from.break_time());
    }
    if (from.has_mab_time()) {
      set_mab_time(from.mab_time());
    }
    if (from.has_rate()) {
      set_rate(from.rate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ParameterReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParameterReply::CopyFrom(const ParameterReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void ParameterReply::Swap(ParameterReply* other) {
  if (other != this) {
    std::swap(firmware_high_, other->firmware_high_);
    std::swap(firmware_, other->firmware_);
    std::swap(break_time_, other->break_time_);
    std::swap(mab_time_, other->mab_time_);
    std::swap(rate_, other->rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ParameterReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ParameterReply_descriptor_;
  metadata.reflection = ParameterReply_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ParameterRequest::kPortIdFieldNumber;
const int ParameterRequest::kBreakTimeFieldNumber;
const int ParameterRequest::kMabTimeFieldNumber;
const int ParameterRequest::kRateFieldNumber;
#endif  // !_MSC_VER

ParameterRequest::ParameterRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.usbpro.ParameterRequest)
}

void ParameterRequest::InitAsDefaultInstance() {
}

ParameterRequest::ParameterRequest(const ParameterRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.ParameterRequest)
}

void ParameterRequest::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = 0u;
  break_time_ = 0u;
  mab_time_ = 0u;
  rate_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParameterRequest::~ParameterRequest() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.ParameterRequest)
  SharedDtor();
}

void ParameterRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ParameterRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParameterRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParameterRequest_descriptor_;
}

const ParameterRequest& ParameterRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_UsbProConfigMessages_2eproto();
  return *default_instance_;
}

ParameterRequest* ParameterRequest::default_instance_ = NULL;

ParameterRequest* ParameterRequest::New() const {
  return new ParameterRequest;
}

void ParameterRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ParameterRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(port_id_, rate_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ParameterRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.usbpro.ParameterRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 break_time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &break_time_)));
          set_has_break_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mab_time;
        break;
      }

      // optional uint32 mab_time = 2;
      case 2: {
        if (tag == 16) {
         parse_mab_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mab_time_)));
          set_has_mab_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_rate;
        break;
      }

      // optional uint32 rate = 3;
      case 3: {
        if (tag == 24) {
         parse_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rate_)));
          set_has_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_port_id;
        break;
      }

      // required uint32 port_id = 4;
      case 4: {
        if (tag == 32) {
         parse_port_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_id_)));
          set_has_port_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.usbpro.ParameterRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.usbpro.ParameterRequest)
  return false;
#undef DO_
}

void ParameterRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.usbpro.ParameterRequest)
  // optional uint32 break_time = 1;
  if (has_break_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->break_time(), output);
  }

  // optional uint32 mab_time = 2;
  if (has_mab_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mab_time(), output);
  }

  // optional uint32 rate = 3;
  if (has_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rate(), output);
  }

  // required uint32 port_id = 4;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->port_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.usbpro.ParameterRequest)
}

::google::protobuf::uint8* ParameterRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.ParameterRequest)
  // optional uint32 break_time = 1;
  if (has_break_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->break_time(), target);
  }

  // optional uint32 mab_time = 2;
  if (has_mab_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->mab_time(), target);
  }

  // optional uint32 rate = 3;
  if (has_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->rate(), target);
  }

  // required uint32 port_id = 4;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->port_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.ParameterRequest)
  return target;
}

int ParameterRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 port_id = 4;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port_id());
    }

    // optional uint32 break_time = 1;
    if (has_break_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->break_time());
    }

    // optional uint32 mab_time = 2;
    if (has_mab_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mab_time());
    }

    // optional uint32 rate = 3;
    if (has_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParameterRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ParameterRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ParameterRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ParameterRequest::MergeFrom(const ParameterRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      set_port_id(from.port_id());
    }
    if (from.has_break_time()) {
      set_break_time(from.break_time());
    }
    if (from.has_mab_time()) {
      set_mab_time(from.mab_time());
    }
    if (from.has_rate()) {
      set_rate(from.rate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ParameterRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParameterRequest::CopyFrom(const ParameterRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ParameterRequest::Swap(ParameterRequest* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    std::swap(break_time_, other->break_time_);
    std::swap(mab_time_, other->mab_time_);
    std::swap(rate_, other->rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ParameterRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ParameterRequest_descriptor_;
  metadata.reflection = ParameterRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SerialNumberReply::kSerialFieldNumber;
#endif  // !_MSC_VER

SerialNumberReply::SerialNumberReply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.usbpro.SerialNumberReply)
}

void SerialNumberReply::InitAsDefaultInstance() {
}

SerialNumberReply::SerialNumberReply(const SerialNumberReply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.SerialNumberReply)
}

void SerialNumberReply::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerialNumberReply::~SerialNumberReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.SerialNumberReply)
  SharedDtor();
}

void SerialNumberReply::SharedDtor() {
  if (serial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serial_;
  }
  if (this != default_instance_) {
  }
}

void SerialNumberReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerialNumberReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerialNumberReply_descriptor_;
}

const SerialNumberReply& SerialNumberReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_UsbProConfigMessages_2eproto();
  return *default_instance_;
}

SerialNumberReply* SerialNumberReply::default_instance_ = NULL;

SerialNumberReply* SerialNumberReply::New() const {
  return new SerialNumberReply;
}

void SerialNumberReply::Clear() {
  if (has_serial()) {
    if (serial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      serial_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerialNumberReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.usbpro.SerialNumberReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string serial = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serial()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->serial().data(), this->serial().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "serial");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.usbpro.SerialNumberReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.usbpro.SerialNumberReply)
  return false;
#undef DO_
}

void SerialNumberReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.usbpro.SerialNumberReply)
  // required string serial = 1;
  if (has_serial()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial().data(), this->serial().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "serial");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->serial(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.usbpro.SerialNumberReply)
}

::google::protobuf::uint8* SerialNumberReply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.SerialNumberReply)
  // required string serial = 1;
  if (has_serial()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->serial().data(), this->serial().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "serial");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->serial(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.SerialNumberReply)
  return target;
}

int SerialNumberReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string serial = 1;
    if (has_serial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serial());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerialNumberReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerialNumberReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerialNumberReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerialNumberReply::MergeFrom(const SerialNumberReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial()) {
      set_serial(from.serial());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerialNumberReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialNumberReply::CopyFrom(const SerialNumberReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialNumberReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SerialNumberReply::Swap(SerialNumberReply* other) {
  if (other != this) {
    std::swap(serial_, other->serial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerialNumberReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerialNumberReply_descriptor_;
  metadata.reflection = SerialNumberReply_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortAssignmentReply::kPortAssignment1FieldNumber;
const int PortAssignmentReply::kPortAssignment2FieldNumber;
#endif  // !_MSC_VER

PortAssignmentReply::PortAssignmentReply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.usbpro.PortAssignmentReply)
}

void PortAssignmentReply::InitAsDefaultInstance() {
}

PortAssignmentReply::PortAssignmentReply(const PortAssignmentReply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.PortAssignmentReply)
}

void PortAssignmentReply::SharedCtor() {
  _cached_size_ = 0;
  port_assignment1_ = 0u;
  port_assignment2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortAssignmentReply::~PortAssignmentReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.PortAssignmentReply)
  SharedDtor();
}

void PortAssignmentReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortAssignmentReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortAssignmentReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortAssignmentReply_descriptor_;
}

const PortAssignmentReply& PortAssignmentReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_UsbProConfigMessages_2eproto();
  return *default_instance_;
}

PortAssignmentReply* PortAssignmentReply::default_instance_ = NULL;

PortAssignmentReply* PortAssignmentReply::New() const {
  return new PortAssignmentReply;
}

void PortAssignmentReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PortAssignmentReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(port_assignment1_, port_assignment2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortAssignmentReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.usbpro.PortAssignmentReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port_assignment1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_assignment1_)));
          set_has_port_assignment1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port_assignment2;
        break;
      }

      // required uint32 port_assignment2 = 2;
      case 2: {
        if (tag == 16) {
         parse_port_assignment2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_assignment2_)));
          set_has_port_assignment2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.usbpro.PortAssignmentReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.usbpro.PortAssignmentReply)
  return false;
#undef DO_
}

void PortAssignmentReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.usbpro.PortAssignmentReply)
  // required uint32 port_assignment1 = 1;
  if (has_port_assignment1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port_assignment1(), output);
  }

  // required uint32 port_assignment2 = 2;
  if (has_port_assignment2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port_assignment2(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.usbpro.PortAssignmentReply)
}

::google::protobuf::uint8* PortAssignmentReply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.PortAssignmentReply)
  // required uint32 port_assignment1 = 1;
  if (has_port_assignment1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port_assignment1(), target);
  }

  // required uint32 port_assignment2 = 2;
  if (has_port_assignment2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->port_assignment2(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.PortAssignmentReply)
  return target;
}

int PortAssignmentReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 port_assignment1 = 1;
    if (has_port_assignment1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port_assignment1());
    }

    // required uint32 port_assignment2 = 2;
    if (has_port_assignment2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port_assignment2());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortAssignmentReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortAssignmentReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortAssignmentReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortAssignmentReply::MergeFrom(const PortAssignmentReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_assignment1()) {
      set_port_assignment1(from.port_assignment1());
    }
    if (from.has_port_assignment2()) {
      set_port_assignment2(from.port_assignment2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortAssignmentReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortAssignmentReply::CopyFrom(const PortAssignmentReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortAssignmentReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PortAssignmentReply::Swap(PortAssignmentReply* other) {
  if (other != this) {
    std::swap(port_assignment1_, other->port_assignment1_);
    std::swap(port_assignment2_, other->port_assignment2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortAssignmentReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortAssignmentReply_descriptor_;
  metadata.reflection = PortAssignmentReply_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_RequestType_descriptor_;
}
bool Request_RequestType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Request_RequestType Request::USBPRO_PARAMETER_REQUEST;
const Request_RequestType Request::USBPRO_SERIAL_REQUEST;
const Request_RequestType Request::USBPRO_PORT_ASSIGNMENT_REQUEST;
const Request_RequestType Request::RequestType_MIN;
const Request_RequestType Request::RequestType_MAX;
const int Request::RequestType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Request::kTypeFieldNumber;
const int Request::kParametersFieldNumber;
#endif  // !_MSC_VER

Request::Request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.usbpro.Request)
}

void Request::InitAsDefaultInstance() {
  parameters_ = const_cast< ::ola::plugin::usbpro::ParameterRequest*>(&::ola::plugin::usbpro::ParameterRequest::default_instance());
}

Request::Request(const Request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.Request)
}

void Request::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  parameters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.Request)
  SharedDtor();
}

void Request::SharedDtor() {
  if (this != default_instance_) {
    delete parameters_;
  }
}

void Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_descriptor_;
}

const Request& Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_UsbProConfigMessages_2eproto();
  return *default_instance_;
}

Request* Request::default_instance_ = NULL;

Request* Request::New() const {
  return new Request;
}

void Request::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    type_ = 1;
    if (has_parameters()) {
      if (parameters_ != NULL) parameters_->::ola::plugin::usbpro::ParameterRequest::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.usbpro.Request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ola.plugin.usbpro.Request.RequestType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ola::plugin::usbpro::Request_RequestType_IsValid(value)) {
            set_type(static_cast< ::ola::plugin::usbpro::Request_RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parameters;
        break;
      }

      // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
      case 2: {
        if (tag == 18) {
         parse_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parameters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.usbpro.Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.usbpro.Request)
  return false;
#undef DO_
}

void Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.usbpro.Request)
  // required .ola.plugin.usbpro.Request.RequestType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
  if (has_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->parameters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.usbpro.Request)
}

::google::protobuf::uint8* Request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.Request)
  // required .ola.plugin.usbpro.Request.RequestType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
  if (has_parameters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->parameters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.Request)
  return target;
}

int Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ola.plugin.usbpro.Request.RequestType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
    if (has_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parameters());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Request::MergeFrom(const Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_parameters()) {
      mutable_parameters()->::ola::plugin::usbpro::ParameterRequest::MergeFrom(from.parameters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Request::CopyFrom(const Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_parameters()) {
    if (!this->parameters().IsInitialized()) return false;
  }
  return true;
}

void Request::Swap(Request* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(parameters_, other->parameters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Request_descriptor_;
  metadata.reflection = Request_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Reply_ReplyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reply_ReplyType_descriptor_;
}
bool Reply_ReplyType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Reply_ReplyType Reply::USBPRO_PARAMETER_REPLY;
const Reply_ReplyType Reply::USBPRO_SERIAL_REPLY;
const Reply_ReplyType Reply::USBPRO_PORT_ASSIGNMENT_REPLY;
const Reply_ReplyType Reply::ReplyType_MIN;
const Reply_ReplyType Reply::ReplyType_MAX;
const int Reply::ReplyType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Reply::kTypeFieldNumber;
const int Reply::kParametersFieldNumber;
const int Reply::kSerialNumberFieldNumber;
const int Reply::kPortAssignmentFieldNumber;
#endif  // !_MSC_VER

Reply::Reply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.usbpro.Reply)
}

void Reply::InitAsDefaultInstance() {
  parameters_ = const_cast< ::ola::plugin::usbpro::ParameterReply*>(&::ola::plugin::usbpro::ParameterReply::default_instance());
  serial_number_ = const_cast< ::ola::plugin::usbpro::SerialNumberReply*>(&::ola::plugin::usbpro::SerialNumberReply::default_instance());
  port_assignment_ = const_cast< ::ola::plugin::usbpro::PortAssignmentReply*>(&::ola::plugin::usbpro::PortAssignmentReply::default_instance());
}

Reply::Reply(const Reply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.Reply)
}

void Reply::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  parameters_ = NULL;
  serial_number_ = NULL;
  port_assignment_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reply::~Reply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.Reply)
  SharedDtor();
}

void Reply::SharedDtor() {
  if (this != default_instance_) {
    delete parameters_;
    delete serial_number_;
    delete port_assignment_;
  }
}

void Reply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Reply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reply_descriptor_;
}

const Reply& Reply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_UsbProConfigMessages_2eproto();
  return *default_instance_;
}

Reply* Reply::default_instance_ = NULL;

Reply* Reply::New() const {
  return new Reply;
}

void Reply::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 1;
    if (has_parameters()) {
      if (parameters_ != NULL) parameters_->::ola::plugin::usbpro::ParameterReply::Clear();
    }
    if (has_serial_number()) {
      if (serial_number_ != NULL) serial_number_->::ola::plugin::usbpro::SerialNumberReply::Clear();
    }
    if (has_port_assignment()) {
      if (port_assignment_ != NULL) port_assignment_->::ola::plugin::usbpro::PortAssignmentReply::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Reply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.usbpro.Reply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ola::plugin::usbpro::Reply_ReplyType_IsValid(value)) {
            set_type(static_cast< ::ola::plugin::usbpro::Reply_ReplyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parameters;
        break;
      }

      // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
      case 2: {
        if (tag == 18) {
         parse_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parameters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_serial_number;
        break;
      }

      // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
      case 3: {
        if (tag == 26) {
         parse_serial_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_serial_number()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_port_assignment;
        break;
      }

      // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
      case 4: {
        if (tag == 34) {
         parse_port_assignment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_assignment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.usbpro.Reply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.usbpro.Reply)
  return false;
#undef DO_
}

void Reply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.usbpro.Reply)
  // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
  if (has_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->parameters(), output);
  }

  // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->serial_number(), output);
  }

  // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
  if (has_port_assignment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->port_assignment(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.usbpro.Reply)
}

::google::protobuf::uint8* Reply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.Reply)
  // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
  if (has_parameters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->parameters(), target);
  }

  // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->serial_number(), target);
  }

  // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
  if (has_port_assignment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->port_assignment(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.Reply)
  return target;
}

int Reply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
    if (has_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parameters());
    }

    // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->serial_number());
    }

    // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
    if (has_port_assignment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_assignment());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Reply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Reply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Reply::MergeFrom(const Reply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_parameters()) {
      mutable_parameters()->::ola::plugin::usbpro::ParameterReply::MergeFrom(from.parameters());
    }
    if (from.has_serial_number()) {
      mutable_serial_number()->::ola::plugin::usbpro::SerialNumberReply::MergeFrom(from.serial_number());
    }
    if (from.has_port_assignment()) {
      mutable_port_assignment()->::ola::plugin::usbpro::PortAssignmentReply::MergeFrom(from.port_assignment());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Reply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reply::CopyFrom(const Reply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_parameters()) {
    if (!this->parameters().IsInitialized()) return false;
  }
  if (has_serial_number()) {
    if (!this->serial_number().IsInitialized()) return false;
  }
  if (has_port_assignment()) {
    if (!this->port_assignment().IsInitialized()) return false;
  }
  return true;
}

void Reply::Swap(Reply* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(parameters_, other->parameters_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(port_assignment_, other->port_assignment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Reply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Reply_descriptor_;
  metadata.reflection = Reply_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace usbpro
}  // namespace plugin
}  // namespace ola

// @@protoc_insertion_point(global_scope)
