// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: E131ConfigMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "E131ConfigMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ola {
namespace plugin {
namespace e131 {

namespace {

const ::google::protobuf::Descriptor* PreviewModeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PreviewModeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* InputPortInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InputPortInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* OutputPortInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OutputPortInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortInfoReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortInfoReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* SourceListRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SourceListRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* SourceEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SourceEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* SourceListReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SourceListReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Request_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Reply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Reply_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Reply_ReplyType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_E131ConfigMessages_2eproto() {
  protobuf_AddDesc_E131ConfigMessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "E131ConfigMessages.proto");
  GOOGLE_CHECK(file != NULL);
  PreviewModeRequest_descriptor_ = file->message_type(0);
  static const int PreviewModeRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreviewModeRequest, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreviewModeRequest, preview_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreviewModeRequest, input_port_),
  };
  PreviewModeRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PreviewModeRequest_descriptor_,
      PreviewModeRequest::default_instance_,
      PreviewModeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreviewModeRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreviewModeRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PreviewModeRequest));
  InputPortInfo_descriptor_ = file->message_type(1);
  static const int InputPortInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPortInfo, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPortInfo, preview_mode_),
  };
  InputPortInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InputPortInfo_descriptor_,
      InputPortInfo::default_instance_,
      InputPortInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPortInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPortInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InputPortInfo));
  OutputPortInfo_descriptor_ = file->message_type(2);
  static const int OutputPortInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OutputPortInfo, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OutputPortInfo, preview_mode_),
  };
  OutputPortInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OutputPortInfo_descriptor_,
      OutputPortInfo::default_instance_,
      OutputPortInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OutputPortInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OutputPortInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OutputPortInfo));
  PortInfoReply_descriptor_ = file->message_type(3);
  static const int PortInfoReply_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortInfoReply, input_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortInfoReply, output_port_),
  };
  PortInfoReply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortInfoReply_descriptor_,
      PortInfoReply::default_instance_,
      PortInfoReply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortInfoReply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortInfoReply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortInfoReply));
  SourceListRequest_descriptor_ = file->message_type(4);
  static const int SourceListRequest_offsets_[1] = {
  };
  SourceListRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SourceListRequest_descriptor_,
      SourceListRequest::default_instance_,
      SourceListRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceListRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceListRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SourceListRequest));
  SourceEntry_descriptor_ = file->message_type(5);
  static const int SourceEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceEntry, cid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceEntry, ip_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceEntry, source_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceEntry, universe_),
  };
  SourceEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SourceEntry_descriptor_,
      SourceEntry::default_instance_,
      SourceEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SourceEntry));
  SourceListReply_descriptor_ = file->message_type(6);
  static const int SourceListReply_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceListReply, unsupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceListReply, source_),
  };
  SourceListReply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SourceListReply_descriptor_,
      SourceListReply::default_instance_,
      SourceListReply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceListReply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SourceListReply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SourceListReply));
  Request_descriptor_ = file->message_type(7);
  static const int Request_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, preview_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, source_list_),
  };
  Request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Request_descriptor_,
      Request::default_instance_,
      Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Request));
  Request_RequestType_descriptor_ = Request_descriptor_->enum_type(0);
  Reply_descriptor_ = file->message_type(8);
  static const int Reply_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, port_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, source_list_),
  };
  Reply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Reply_descriptor_,
      Reply::default_instance_,
      Reply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Reply));
  Reply_ReplyType_descriptor_ = Reply_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_E131ConfigMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PreviewModeRequest_descriptor_, &PreviewModeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InputPortInfo_descriptor_, &InputPortInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OutputPortInfo_descriptor_, &OutputPortInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortInfoReply_descriptor_, &PortInfoReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SourceListRequest_descriptor_, &SourceListRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SourceEntry_descriptor_, &SourceEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SourceListReply_descriptor_, &SourceListReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Request_descriptor_, &Request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Reply_descriptor_, &Reply::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_E131ConfigMessages_2eproto() {
  delete PreviewModeRequest::default_instance_;
  delete PreviewModeRequest_reflection_;
  delete InputPortInfo::default_instance_;
  delete InputPortInfo_reflection_;
  delete OutputPortInfo::default_instance_;
  delete OutputPortInfo_reflection_;
  delete PortInfoReply::default_instance_;
  delete PortInfoReply_reflection_;
  delete SourceListRequest::default_instance_;
  delete SourceListRequest_reflection_;
  delete SourceEntry::default_instance_;
  delete SourceEntry_reflection_;
  delete SourceListReply::default_instance_;
  delete SourceListReply_reflection_;
  delete Request::default_instance_;
  delete Request_reflection_;
  delete Reply::default_instance_;
  delete Reply_reflection_;
}

void protobuf_AddDesc_E131ConfigMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\030E131ConfigMessages.proto\022\017ola.plugin.e"
    "131\"O\n\022PreviewModeRequest\022\017\n\007port_id\030\001 \002"
    "(\005\022\024\n\014preview_mode\030\002 \002(\010\022\022\n\ninput_port\030\003"
    " \002(\010\"6\n\rInputPortInfo\022\017\n\007port_id\030\001 \002(\005\022\024"
    "\n\014preview_mode\030\002 \002(\010\"7\n\016OutputPortInfo\022\017"
    "\n\007port_id\030\001 \002(\005\022\024\n\014preview_mode\030\002 \002(\010\"y\n"
    "\rPortInfoReply\0222\n\ninput_port\030\001 \003(\0132\036.ola"
    ".plugin.e131.InputPortInfo\0224\n\013output_por"
    "t\030\002 \003(\0132\037.ola.plugin.e131.OutputPortInfo"
    "\"\023\n\021SourceListRequest\"U\n\013SourceEntry\022\013\n\003"
    "cid\030\001 \002(\t\022\022\n\nip_address\030\002 \002(\t\022\023\n\013source_"
    "name\030\003 \001(\t\022\020\n\010universe\030\004 \003(\005\"Z\n\017SourceLi"
    "stReply\022\031\n\013unsupported\030\001 \001(\010:\004true\022,\n\006so"
    "urce\030\002 \003(\0132\034.ola.plugin.e131.SourceEntry"
    "\"\202\002\n\007Request\0222\n\004type\030\001 \002(\0162$.ola.plugin."
    "e131.Request.RequestType\0229\n\014preview_mode"
    "\030\002 \001(\0132#.ola.plugin.e131.PreviewModeRequ"
    "est\0227\n\013source_list\030\003 \001(\0132\".ola.plugin.e1"
    "31.SourceListRequest\"O\n\013RequestType\022\022\n\016E"
    "131_PORT_INFO\020\001\022\025\n\021E131_PREVIEW_MODE\020\002\022\025"
    "\n\021E131_SOURCES_LIST\020\003\"\331\001\n\005Reply\022.\n\004type\030"
    "\001 \002(\0162 .ola.plugin.e131.Reply.ReplyType\022"
    "1\n\tport_info\030\002 \001(\0132\036.ola.plugin.e131.Por"
    "tInfoReply\0225\n\013source_list\030\003 \001(\0132 .ola.pl"
    "ugin.e131.SourceListReply\"6\n\tReplyType\022\022"
    "\n\016E131_PORT_INFO\020\001\022\025\n\021E131_SOURCES_LIST\020"
    "\002", 1041);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "E131ConfigMessages.proto", &protobuf_RegisterTypes);
  PreviewModeRequest::default_instance_ = new PreviewModeRequest();
  InputPortInfo::default_instance_ = new InputPortInfo();
  OutputPortInfo::default_instance_ = new OutputPortInfo();
  PortInfoReply::default_instance_ = new PortInfoReply();
  SourceListRequest::default_instance_ = new SourceListRequest();
  SourceEntry::default_instance_ = new SourceEntry();
  SourceListReply::default_instance_ = new SourceListReply();
  Request::default_instance_ = new Request();
  Reply::default_instance_ = new Reply();
  PreviewModeRequest::default_instance_->InitAsDefaultInstance();
  InputPortInfo::default_instance_->InitAsDefaultInstance();
  OutputPortInfo::default_instance_->InitAsDefaultInstance();
  PortInfoReply::default_instance_->InitAsDefaultInstance();
  SourceListRequest::default_instance_->InitAsDefaultInstance();
  SourceEntry::default_instance_->InitAsDefaultInstance();
  SourceListReply::default_instance_->InitAsDefaultInstance();
  Request::default_instance_->InitAsDefaultInstance();
  Reply::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_E131ConfigMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_E131ConfigMessages_2eproto {
  StaticDescriptorInitializer_E131ConfigMessages_2eproto() {
    protobuf_AddDesc_E131ConfigMessages_2eproto();
  }
} static_descriptor_initializer_E131ConfigMessages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int PreviewModeRequest::kPortIdFieldNumber;
const int PreviewModeRequest::kPreviewModeFieldNumber;
const int PreviewModeRequest::kInputPortFieldNumber;
#endif  // !_MSC_VER

PreviewModeRequest::PreviewModeRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.PreviewModeRequest)
}

void PreviewModeRequest::InitAsDefaultInstance() {
}

PreviewModeRequest::PreviewModeRequest(const PreviewModeRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.PreviewModeRequest)
}

void PreviewModeRequest::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = 0;
  preview_mode_ = false;
  input_port_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PreviewModeRequest::~PreviewModeRequest() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.PreviewModeRequest)
  SharedDtor();
}

void PreviewModeRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PreviewModeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PreviewModeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PreviewModeRequest_descriptor_;
}

const PreviewModeRequest& PreviewModeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

PreviewModeRequest* PreviewModeRequest::default_instance_ = NULL;

PreviewModeRequest* PreviewModeRequest::New() const {
  return new PreviewModeRequest;
}

void PreviewModeRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PreviewModeRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(port_id_, input_port_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PreviewModeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.PreviewModeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 port_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_id_)));
          set_has_port_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_preview_mode;
        break;
      }

      // required bool preview_mode = 2;
      case 2: {
        if (tag == 16) {
         parse_preview_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &preview_mode_)));
          set_has_preview_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_input_port;
        break;
      }

      // required bool input_port = 3;
      case 3: {
        if (tag == 24) {
         parse_input_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &input_port_)));
          set_has_input_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.PreviewModeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.PreviewModeRequest)
  return false;
#undef DO_
}

void PreviewModeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.PreviewModeRequest)
  // required int32 port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->port_id(), output);
  }

  // required bool preview_mode = 2;
  if (has_preview_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->preview_mode(), output);
  }

  // required bool input_port = 3;
  if (has_input_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->input_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.PreviewModeRequest)
}

::google::protobuf::uint8* PreviewModeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.PreviewModeRequest)
  // required int32 port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->port_id(), target);
  }

  // required bool preview_mode = 2;
  if (has_preview_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->preview_mode(), target);
  }

  // required bool input_port = 3;
  if (has_input_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->input_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.PreviewModeRequest)
  return target;
}

int PreviewModeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port_id());
    }

    // required bool preview_mode = 2;
    if (has_preview_mode()) {
      total_size += 1 + 1;
    }

    // required bool input_port = 3;
    if (has_input_port()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PreviewModeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PreviewModeRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PreviewModeRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PreviewModeRequest::MergeFrom(const PreviewModeRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      set_port_id(from.port_id());
    }
    if (from.has_preview_mode()) {
      set_preview_mode(from.preview_mode());
    }
    if (from.has_input_port()) {
      set_input_port(from.input_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PreviewModeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PreviewModeRequest::CopyFrom(const PreviewModeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PreviewModeRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void PreviewModeRequest::Swap(PreviewModeRequest* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    std::swap(preview_mode_, other->preview_mode_);
    std::swap(input_port_, other->input_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PreviewModeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PreviewModeRequest_descriptor_;
  metadata.reflection = PreviewModeRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InputPortInfo::kPortIdFieldNumber;
const int InputPortInfo::kPreviewModeFieldNumber;
#endif  // !_MSC_VER

InputPortInfo::InputPortInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.InputPortInfo)
}

void InputPortInfo::InitAsDefaultInstance() {
}

InputPortInfo::InputPortInfo(const InputPortInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.InputPortInfo)
}

void InputPortInfo::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = 0;
  preview_mode_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InputPortInfo::~InputPortInfo() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.InputPortInfo)
  SharedDtor();
}

void InputPortInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InputPortInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InputPortInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InputPortInfo_descriptor_;
}

const InputPortInfo& InputPortInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

InputPortInfo* InputPortInfo::default_instance_ = NULL;

InputPortInfo* InputPortInfo::New() const {
  return new InputPortInfo;
}

void InputPortInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<InputPortInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(port_id_, preview_mode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InputPortInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.InputPortInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 port_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_id_)));
          set_has_port_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_preview_mode;
        break;
      }

      // required bool preview_mode = 2;
      case 2: {
        if (tag == 16) {
         parse_preview_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &preview_mode_)));
          set_has_preview_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.InputPortInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.InputPortInfo)
  return false;
#undef DO_
}

void InputPortInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.InputPortInfo)
  // required int32 port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->port_id(), output);
  }

  // required bool preview_mode = 2;
  if (has_preview_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->preview_mode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.InputPortInfo)
}

::google::protobuf::uint8* InputPortInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.InputPortInfo)
  // required int32 port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->port_id(), target);
  }

  // required bool preview_mode = 2;
  if (has_preview_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->preview_mode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.InputPortInfo)
  return target;
}

int InputPortInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port_id());
    }

    // required bool preview_mode = 2;
    if (has_preview_mode()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InputPortInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InputPortInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InputPortInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InputPortInfo::MergeFrom(const InputPortInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      set_port_id(from.port_id());
    }
    if (from.has_preview_mode()) {
      set_preview_mode(from.preview_mode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InputPortInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InputPortInfo::CopyFrom(const InputPortInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputPortInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void InputPortInfo::Swap(InputPortInfo* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    std::swap(preview_mode_, other->preview_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InputPortInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InputPortInfo_descriptor_;
  metadata.reflection = InputPortInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OutputPortInfo::kPortIdFieldNumber;
const int OutputPortInfo::kPreviewModeFieldNumber;
#endif  // !_MSC_VER

OutputPortInfo::OutputPortInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.OutputPortInfo)
}

void OutputPortInfo::InitAsDefaultInstance() {
}

OutputPortInfo::OutputPortInfo(const OutputPortInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.OutputPortInfo)
}

void OutputPortInfo::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = 0;
  preview_mode_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OutputPortInfo::~OutputPortInfo() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.OutputPortInfo)
  SharedDtor();
}

void OutputPortInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OutputPortInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OutputPortInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OutputPortInfo_descriptor_;
}

const OutputPortInfo& OutputPortInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

OutputPortInfo* OutputPortInfo::default_instance_ = NULL;

OutputPortInfo* OutputPortInfo::New() const {
  return new OutputPortInfo;
}

void OutputPortInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OutputPortInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(port_id_, preview_mode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OutputPortInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.OutputPortInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 port_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_id_)));
          set_has_port_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_preview_mode;
        break;
      }

      // required bool preview_mode = 2;
      case 2: {
        if (tag == 16) {
         parse_preview_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &preview_mode_)));
          set_has_preview_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.OutputPortInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.OutputPortInfo)
  return false;
#undef DO_
}

void OutputPortInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.OutputPortInfo)
  // required int32 port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->port_id(), output);
  }

  // required bool preview_mode = 2;
  if (has_preview_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->preview_mode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.OutputPortInfo)
}

::google::protobuf::uint8* OutputPortInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.OutputPortInfo)
  // required int32 port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->port_id(), target);
  }

  // required bool preview_mode = 2;
  if (has_preview_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->preview_mode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.OutputPortInfo)
  return target;
}

int OutputPortInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port_id());
    }

    // required bool preview_mode = 2;
    if (has_preview_mode()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputPortInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OutputPortInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OutputPortInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OutputPortInfo::MergeFrom(const OutputPortInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      set_port_id(from.port_id());
    }
    if (from.has_preview_mode()) {
      set_preview_mode(from.preview_mode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OutputPortInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OutputPortInfo::CopyFrom(const OutputPortInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputPortInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OutputPortInfo::Swap(OutputPortInfo* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    std::swap(preview_mode_, other->preview_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OutputPortInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OutputPortInfo_descriptor_;
  metadata.reflection = OutputPortInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortInfoReply::kInputPortFieldNumber;
const int PortInfoReply::kOutputPortFieldNumber;
#endif  // !_MSC_VER

PortInfoReply::PortInfoReply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.PortInfoReply)
}

void PortInfoReply::InitAsDefaultInstance() {
}

PortInfoReply::PortInfoReply(const PortInfoReply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.PortInfoReply)
}

void PortInfoReply::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortInfoReply::~PortInfoReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.PortInfoReply)
  SharedDtor();
}

void PortInfoReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortInfoReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortInfoReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortInfoReply_descriptor_;
}

const PortInfoReply& PortInfoReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

PortInfoReply* PortInfoReply::default_instance_ = NULL;

PortInfoReply* PortInfoReply::New() const {
  return new PortInfoReply;
}

void PortInfoReply::Clear() {
  input_port_.Clear();
  output_port_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortInfoReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.PortInfoReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ola.plugin.e131.InputPortInfo input_port = 1;
      case 1: {
        if (tag == 10) {
         parse_input_port:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_input_port()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_input_port;
        if (input->ExpectTag(18)) goto parse_output_port;
        break;
      }

      // repeated .ola.plugin.e131.OutputPortInfo output_port = 2;
      case 2: {
        if (tag == 18) {
         parse_output_port:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_output_port()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_output_port;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.PortInfoReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.PortInfoReply)
  return false;
#undef DO_
}

void PortInfoReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.PortInfoReply)
  // repeated .ola.plugin.e131.InputPortInfo input_port = 1;
  for (int i = 0; i < this->input_port_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->input_port(i), output);
  }

  // repeated .ola.plugin.e131.OutputPortInfo output_port = 2;
  for (int i = 0; i < this->output_port_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->output_port(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.PortInfoReply)
}

::google::protobuf::uint8* PortInfoReply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.PortInfoReply)
  // repeated .ola.plugin.e131.InputPortInfo input_port = 1;
  for (int i = 0; i < this->input_port_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->input_port(i), target);
  }

  // repeated .ola.plugin.e131.OutputPortInfo output_port = 2;
  for (int i = 0; i < this->output_port_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->output_port(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.PortInfoReply)
  return target;
}

int PortInfoReply::ByteSize() const {
  int total_size = 0;

  // repeated .ola.plugin.e131.InputPortInfo input_port = 1;
  total_size += 1 * this->input_port_size();
  for (int i = 0; i < this->input_port_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->input_port(i));
  }

  // repeated .ola.plugin.e131.OutputPortInfo output_port = 2;
  total_size += 1 * this->output_port_size();
  for (int i = 0; i < this->output_port_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->output_port(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortInfoReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortInfoReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortInfoReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortInfoReply::MergeFrom(const PortInfoReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  input_port_.MergeFrom(from.input_port_);
  output_port_.MergeFrom(from.output_port_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortInfoReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortInfoReply::CopyFrom(const PortInfoReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortInfoReply::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->input_port())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->output_port())) return false;
  return true;
}

void PortInfoReply::Swap(PortInfoReply* other) {
  if (other != this) {
    input_port_.Swap(&other->input_port_);
    output_port_.Swap(&other->output_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortInfoReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortInfoReply_descriptor_;
  metadata.reflection = PortInfoReply_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

SourceListRequest::SourceListRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.SourceListRequest)
}

void SourceListRequest::InitAsDefaultInstance() {
}

SourceListRequest::SourceListRequest(const SourceListRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.SourceListRequest)
}

void SourceListRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SourceListRequest::~SourceListRequest() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.SourceListRequest)
  SharedDtor();
}

void SourceListRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SourceListRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SourceListRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SourceListRequest_descriptor_;
}

const SourceListRequest& SourceListRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

SourceListRequest* SourceListRequest::default_instance_ = NULL;

SourceListRequest* SourceListRequest::New() const {
  return new SourceListRequest;
}

void SourceListRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SourceListRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.SourceListRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.SourceListRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.SourceListRequest)
  return false;
#undef DO_
}

void SourceListRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.SourceListRequest)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.SourceListRequest)
}

::google::protobuf::uint8* SourceListRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.SourceListRequest)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.SourceListRequest)
  return target;
}

int SourceListRequest::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SourceListRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SourceListRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SourceListRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SourceListRequest::MergeFrom(const SourceListRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SourceListRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SourceListRequest::CopyFrom(const SourceListRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceListRequest::IsInitialized() const {

  return true;
}

void SourceListRequest::Swap(SourceListRequest* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SourceListRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SourceListRequest_descriptor_;
  metadata.reflection = SourceListRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SourceEntry::kCidFieldNumber;
const int SourceEntry::kIpAddressFieldNumber;
const int SourceEntry::kSourceNameFieldNumber;
const int SourceEntry::kUniverseFieldNumber;
#endif  // !_MSC_VER

SourceEntry::SourceEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.SourceEntry)
}

void SourceEntry::InitAsDefaultInstance() {
}

SourceEntry::SourceEntry(const SourceEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.SourceEntry)
}

void SourceEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SourceEntry::~SourceEntry() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.SourceEntry)
  SharedDtor();
}

void SourceEntry::SharedDtor() {
  if (cid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cid_;
  }
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (source_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_name_;
  }
  if (this != default_instance_) {
  }
}

void SourceEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SourceEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SourceEntry_descriptor_;
}

const SourceEntry& SourceEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

SourceEntry* SourceEntry::default_instance_ = NULL;

SourceEntry* SourceEntry::New() const {
  return new SourceEntry;
}

void SourceEntry::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_cid()) {
      if (cid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        cid_->clear();
      }
    }
    if (has_ip_address()) {
      if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_address_->clear();
      }
    }
    if (has_source_name()) {
      if (source_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        source_name_->clear();
      }
    }
  }
  universe_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SourceEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.SourceEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string cid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->cid().data(), this->cid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip_address;
        break;
      }

      // required string ip_address = 2;
      case 2: {
        if (tag == 18) {
         parse_ip_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip_address().data(), this->ip_address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip_address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source_name;
        break;
      }

      // optional string source_name = 3;
      case 3: {
        if (tag == 26) {
         parse_source_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->source_name().data(), this->source_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "source_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_universe;
        break;
      }

      // repeated int32 universe = 4;
      case 4: {
        if (tag == 32) {
         parse_universe:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_universe())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_universe())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_universe;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.SourceEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.SourceEntry)
  return false;
#undef DO_
}

void SourceEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.SourceEntry)
  // required string cid = 1;
  if (has_cid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cid().data(), this->cid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->cid(), output);
  }

  // required string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip_address(), output);
  }

  // optional string source_name = 3;
  if (has_source_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source_name().data(), this->source_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->source_name(), output);
  }

  // repeated int32 universe = 4;
  for (int i = 0; i < this->universe_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->universe(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.SourceEntry)
}

::google::protobuf::uint8* SourceEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.SourceEntry)
  // required string cid = 1;
  if (has_cid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cid().data(), this->cid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->cid(), target);
  }

  // required string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip_address(), target);
  }

  // optional string source_name = 3;
  if (has_source_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source_name().data(), this->source_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->source_name(), target);
  }

  // repeated int32 universe = 4;
  for (int i = 0; i < this->universe_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->universe(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.SourceEntry)
  return target;
}

int SourceEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string cid = 1;
    if (has_cid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cid());
    }

    // required string ip_address = 2;
    if (has_ip_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip_address());
    }

    // optional string source_name = 3;
    if (has_source_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source_name());
    }

  }
  // repeated int32 universe = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->universe_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->universe(i));
    }
    total_size += 1 * this->universe_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SourceEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SourceEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SourceEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SourceEntry::MergeFrom(const SourceEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  universe_.MergeFrom(from.universe_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cid()) {
      set_cid(from.cid());
    }
    if (from.has_ip_address()) {
      set_ip_address(from.ip_address());
    }
    if (from.has_source_name()) {
      set_source_name(from.source_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SourceEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SourceEntry::CopyFrom(const SourceEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SourceEntry::Swap(SourceEntry* other) {
  if (other != this) {
    std::swap(cid_, other->cid_);
    std::swap(ip_address_, other->ip_address_);
    std::swap(source_name_, other->source_name_);
    universe_.Swap(&other->universe_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SourceEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SourceEntry_descriptor_;
  metadata.reflection = SourceEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SourceListReply::kUnsupportedFieldNumber;
const int SourceListReply::kSourceFieldNumber;
#endif  // !_MSC_VER

SourceListReply::SourceListReply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.SourceListReply)
}

void SourceListReply::InitAsDefaultInstance() {
}

SourceListReply::SourceListReply(const SourceListReply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.SourceListReply)
}

void SourceListReply::SharedCtor() {
  _cached_size_ = 0;
  unsupported_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SourceListReply::~SourceListReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.SourceListReply)
  SharedDtor();
}

void SourceListReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SourceListReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SourceListReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SourceListReply_descriptor_;
}

const SourceListReply& SourceListReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

SourceListReply* SourceListReply::default_instance_ = NULL;

SourceListReply* SourceListReply::New() const {
  return new SourceListReply;
}

void SourceListReply::Clear() {
  unsupported_ = true;
  source_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SourceListReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.SourceListReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool unsupported = 1 [default = true];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unsupported_)));
          set_has_unsupported();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source;
        break;
      }

      // repeated .ola.plugin.e131.SourceEntry source = 2;
      case 2: {
        if (tag == 18) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.SourceListReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.SourceListReply)
  return false;
#undef DO_
}

void SourceListReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.SourceListReply)
  // optional bool unsupported = 1 [default = true];
  if (has_unsupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->unsupported(), output);
  }

  // repeated .ola.plugin.e131.SourceEntry source = 2;
  for (int i = 0; i < this->source_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->source(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.SourceListReply)
}

::google::protobuf::uint8* SourceListReply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.SourceListReply)
  // optional bool unsupported = 1 [default = true];
  if (has_unsupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->unsupported(), target);
  }

  // repeated .ola.plugin.e131.SourceEntry source = 2;
  for (int i = 0; i < this->source_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->source(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.SourceListReply)
  return target;
}

int SourceListReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool unsupported = 1 [default = true];
    if (has_unsupported()) {
      total_size += 1 + 1;
    }

  }
  // repeated .ola.plugin.e131.SourceEntry source = 2;
  total_size += 1 * this->source_size();
  for (int i = 0; i < this->source_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->source(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SourceListReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SourceListReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SourceListReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SourceListReply::MergeFrom(const SourceListReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  source_.MergeFrom(from.source_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unsupported()) {
      set_unsupported(from.unsupported());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SourceListReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SourceListReply::CopyFrom(const SourceListReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceListReply::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->source())) return false;
  return true;
}

void SourceListReply::Swap(SourceListReply* other) {
  if (other != this) {
    std::swap(unsupported_, other->unsupported_);
    source_.Swap(&other->source_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SourceListReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SourceListReply_descriptor_;
  metadata.reflection = SourceListReply_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_RequestType_descriptor_;
}
bool Request_RequestType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Request_RequestType Request::E131_PORT_INFO;
const Request_RequestType Request::E131_PREVIEW_MODE;
const Request_RequestType Request::E131_SOURCES_LIST;
const Request_RequestType Request::RequestType_MIN;
const Request_RequestType Request::RequestType_MAX;
const int Request::RequestType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Request::kTypeFieldNumber;
const int Request::kPreviewModeFieldNumber;
const int Request::kSourceListFieldNumber;
#endif  // !_MSC_VER

Request::Request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.Request)
}

void Request::InitAsDefaultInstance() {
  preview_mode_ = const_cast< ::ola::plugin::e131::PreviewModeRequest*>(&::ola::plugin::e131::PreviewModeRequest::default_instance());
  source_list_ = const_cast< ::ola::plugin::e131::SourceListRequest*>(&::ola::plugin::e131::SourceListRequest::default_instance());
}

Request::Request(const Request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.Request)
}

void Request::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  preview_mode_ = NULL;
  source_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.Request)
  SharedDtor();
}

void Request::SharedDtor() {
  if (this != default_instance_) {
    delete preview_mode_;
    delete source_list_;
  }
}

void Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_descriptor_;
}

const Request& Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

Request* Request::default_instance_ = NULL;

Request* Request::New() const {
  return new Request;
}

void Request::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 1;
    if (has_preview_mode()) {
      if (preview_mode_ != NULL) preview_mode_->::ola::plugin::e131::PreviewModeRequest::Clear();
    }
    if (has_source_list()) {
      if (source_list_ != NULL) source_list_->::ola::plugin::e131::SourceListRequest::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.Request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ola.plugin.e131.Request.RequestType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ola::plugin::e131::Request_RequestType_IsValid(value)) {
            set_type(static_cast< ::ola::plugin::e131::Request_RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_preview_mode;
        break;
      }

      // optional .ola.plugin.e131.PreviewModeRequest preview_mode = 2;
      case 2: {
        if (tag == 18) {
         parse_preview_mode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_preview_mode()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source_list;
        break;
      }

      // optional .ola.plugin.e131.SourceListRequest source_list = 3;
      case 3: {
        if (tag == 26) {
         parse_source_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.Request)
  return false;
#undef DO_
}

void Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.Request)
  // required .ola.plugin.e131.Request.RequestType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .ola.plugin.e131.PreviewModeRequest preview_mode = 2;
  if (has_preview_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->preview_mode(), output);
  }

  // optional .ola.plugin.e131.SourceListRequest source_list = 3;
  if (has_source_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->source_list(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.Request)
}

::google::protobuf::uint8* Request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.Request)
  // required .ola.plugin.e131.Request.RequestType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .ola.plugin.e131.PreviewModeRequest preview_mode = 2;
  if (has_preview_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->preview_mode(), target);
  }

  // optional .ola.plugin.e131.SourceListRequest source_list = 3;
  if (has_source_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->source_list(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.Request)
  return target;
}

int Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ola.plugin.e131.Request.RequestType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ola.plugin.e131.PreviewModeRequest preview_mode = 2;
    if (has_preview_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->preview_mode());
    }

    // optional .ola.plugin.e131.SourceListRequest source_list = 3;
    if (has_source_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source_list());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Request::MergeFrom(const Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_preview_mode()) {
      mutable_preview_mode()->::ola::plugin::e131::PreviewModeRequest::MergeFrom(from.preview_mode());
    }
    if (from.has_source_list()) {
      mutable_source_list()->::ola::plugin::e131::SourceListRequest::MergeFrom(from.source_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Request::CopyFrom(const Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_preview_mode()) {
    if (!this->preview_mode().IsInitialized()) return false;
  }
  return true;
}

void Request::Swap(Request* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(preview_mode_, other->preview_mode_);
    std::swap(source_list_, other->source_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Request_descriptor_;
  metadata.reflection = Request_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Reply_ReplyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reply_ReplyType_descriptor_;
}
bool Reply_ReplyType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Reply_ReplyType Reply::E131_PORT_INFO;
const Reply_ReplyType Reply::E131_SOURCES_LIST;
const Reply_ReplyType Reply::ReplyType_MIN;
const Reply_ReplyType Reply::ReplyType_MAX;
const int Reply::ReplyType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Reply::kTypeFieldNumber;
const int Reply::kPortInfoFieldNumber;
const int Reply::kSourceListFieldNumber;
#endif  // !_MSC_VER

Reply::Reply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ola.plugin.e131.Reply)
}

void Reply::InitAsDefaultInstance() {
  port_info_ = const_cast< ::ola::plugin::e131::PortInfoReply*>(&::ola::plugin::e131::PortInfoReply::default_instance());
  source_list_ = const_cast< ::ola::plugin::e131::SourceListReply*>(&::ola::plugin::e131::SourceListReply::default_instance());
}

Reply::Reply(const Reply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ola.plugin.e131.Reply)
}

void Reply::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  port_info_ = NULL;
  source_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reply::~Reply() {
  // @@protoc_insertion_point(destructor:ola.plugin.e131.Reply)
  SharedDtor();
}

void Reply::SharedDtor() {
  if (this != default_instance_) {
    delete port_info_;
    delete source_list_;
  }
}

void Reply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Reply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reply_descriptor_;
}

const Reply& Reply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_E131ConfigMessages_2eproto();
  return *default_instance_;
}

Reply* Reply::default_instance_ = NULL;

Reply* Reply::New() const {
  return new Reply;
}

void Reply::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 1;
    if (has_port_info()) {
      if (port_info_ != NULL) port_info_->::ola::plugin::e131::PortInfoReply::Clear();
    }
    if (has_source_list()) {
      if (source_list_ != NULL) source_list_->::ola::plugin::e131::SourceListReply::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Reply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ola.plugin.e131.Reply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ola.plugin.e131.Reply.ReplyType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ola::plugin::e131::Reply_ReplyType_IsValid(value)) {
            set_type(static_cast< ::ola::plugin::e131::Reply_ReplyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_port_info;
        break;
      }

      // optional .ola.plugin.e131.PortInfoReply port_info = 2;
      case 2: {
        if (tag == 18) {
         parse_port_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source_list;
        break;
      }

      // optional .ola.plugin.e131.SourceListReply source_list = 3;
      case 3: {
        if (tag == 26) {
         parse_source_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ola.plugin.e131.Reply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ola.plugin.e131.Reply)
  return false;
#undef DO_
}

void Reply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ola.plugin.e131.Reply)
  // required .ola.plugin.e131.Reply.ReplyType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .ola.plugin.e131.PortInfoReply port_info = 2;
  if (has_port_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->port_info(), output);
  }

  // optional .ola.plugin.e131.SourceListReply source_list = 3;
  if (has_source_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->source_list(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ola.plugin.e131.Reply)
}

::google::protobuf::uint8* Reply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.e131.Reply)
  // required .ola.plugin.e131.Reply.ReplyType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .ola.plugin.e131.PortInfoReply port_info = 2;
  if (has_port_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->port_info(), target);
  }

  // optional .ola.plugin.e131.SourceListReply source_list = 3;
  if (has_source_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->source_list(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.e131.Reply)
  return target;
}

int Reply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ola.plugin.e131.Reply.ReplyType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ola.plugin.e131.PortInfoReply port_info = 2;
    if (has_port_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_info());
    }

    // optional .ola.plugin.e131.SourceListReply source_list = 3;
    if (has_source_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source_list());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Reply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Reply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Reply::MergeFrom(const Reply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_port_info()) {
      mutable_port_info()->::ola::plugin::e131::PortInfoReply::MergeFrom(from.port_info());
    }
    if (from.has_source_list()) {
      mutable_source_list()->::ola::plugin::e131::SourceListReply::MergeFrom(from.source_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Reply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reply::CopyFrom(const Reply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_port_info()) {
    if (!this->port_info().IsInitialized()) return false;
  }
  if (has_source_list()) {
    if (!this->source_list().IsInitialized()) return false;
  }
  return true;
}

void Reply::Swap(Reply* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(port_info_, other->port_info_);
    std::swap(source_list_, other->source_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Reply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Reply_descriptor_;
  metadata.reflection = Reply_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace e131
}  // namespace plugin
}  // namespace ola

// @@protoc_insertion_point(global_scope)
